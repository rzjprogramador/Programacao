 ==========   ========
 
plataformas_RunTimes_implementacoes:
extensao_arquivos: .go
rodar_arquivo_isolado_no_console: go run arquivo.go

iniciar_projeto: 
  pasta_projeto: Na pasta do sistema onde esta o GO/src em src criar a pasta do projeto
  modularizar: 
    iniciar_modularizacao: go mod init
    modularizacao_va_gerar: go.mod

  gerenciador_de_dependencias: o sistema vai gerar automaticamente o go.sum que vai gerenciar as dependencias.
  
  obrigatoridade_em_arquivo_principal_portaentrada: criar pacotePrincipal ex: package main

  funcionalidade_obrigatoria_em_arquivo_principal: funcao main() no arquivo principal é obrigatorio ex: func main () {}

  obrigatoridade_em_outros_arquivo: criar seus respectivos pacotes

  ---
  sintaxes_obrigatorias :
    aspas_duplas_em_textos: sim,
    virgula_no_ultimo_campo_de_objeto: sim
    nomes_de_pacotes: nao pode usar caracteres especiais , handerline em nomes de pacotes em golang.

convencoes: 
  nomeDePastasModulos: coloque o nome da pasta de modulo o mesmo nome do pacote/package

importacoes:
  importar_pacotes: import "<NOME_DO_MODULO_PRINCIPAL_NO_GO.MOD>/pastaComMesmoNomeDePacote"
  sintaxe_importacoes_arquivo: import ("pacote1" "moduloPrincipal/pacote2")

tornar_exportavel:
  funcoes_exportaveis: as funcoes exportaveis temq ue começar obrigatoriamente com a PrimeiraLetraMaiuscula

  definidor_de_formatoModelo:
  observacao: os definidores de formatoModelo sao declarados fora de funcoes em espaço livre.

  modelador_objeto:
    contrato : nao tem
    formato: struct , obs: struct já faz a funcao como uma classe e type, sintax : type Nome struct { campo: tipo }

  modelador_funcao:
    interface: em golang a interface serve para unir mais que um formato em um só e prover pra quem precisa a representacao de um metodo com mais que um tipo embutido.